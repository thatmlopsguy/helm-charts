# Default values for global chart.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# Override chart and release names
nameOverride: ""
fullnameOverride: ""

# Additional labels to apply to all resources
labels: {}

# Namespace to deploy to (defaults to release namespace)
namespace: ""

# Multiple deployments configuration
# This allows deploying multiple applications from a single chart
# Each deployment MUST have its own image configuration
deployments: # {}
  # Example configuration:
  frontend:
    enabled: true
    replicaCount: 2
    image:
      registry: ""           # Optional: container registry
      repository: nginx      # Required: image repository
      tag: "1.21.6"          # Required: image tag
      pullPolicy: IfNotPresent
    ports:
      - name: http
        containerPort: 80
        protocol: TCP
    service:
      enabled: true
      type: ClusterIP        # ClusterIP, NodePort, LoadBalancer, ExternalName
      ports:
        - name: http
          port: 80
          targetPort: http
          protocol: TCP
      annotations: {}
    ingress:
      enabled: true
      className: ""          # Ingress class (e.g., nginx, traefik)
      annotations: {}
        # kubernetes.io/ingress.class: nginx
        # kubernetes.io/tls-acme: "true"
        # nginx.ingress.kubernetes.io/rewrite-target: /
      hosts:
        - host: frontend.example.com
          paths:
            - path: /
              pathType: Prefix
              servicePort: 80
      tls: []
        # - secretName: frontend-tls
        #   hosts:
        #     - frontend.example.com
    resources:
      limits:
        cpu: 500m
        memory: 512Mi
      requests:
        cpu: 250m
        memory: 256Mi
    livenessProbe:
      httpGet:
        path: /
        port: http
    readinessProbe:
      httpGet:
        path: /
        port: http

  backend:
    enabled: true
    replicaCount: 3
    image:
      repository: my-app/backend  # Required: each deployment needs its own image
      tag: "v1.0.0"             # Required: specific version for this deployment
    ports:
      - name: api
        containerPort: 8080
    service:
      enabled: true
      type: ClusterIP
      ports:
        - name: api
          port: 8080
          targetPort: api
          protocol: TCP
        - name: metrics
          port: 9090
          targetPort: 9090
          protocol: TCP
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "9090"
    ingress:
      enabled: true
      className: "nginx"
      annotations:
        nginx.ingress.kubernetes.io/rewrite-target: /
        nginx.ingress.kubernetes.io/cors-allow-origin: "*"
      hosts:
        - host: api.example.com
          paths:
            - path: /api
              pathType: Prefix
              servicePort: 8080
        - host: backend.example.com
          paths:
            - path: /
              pathType: Prefix
              servicePort: 8080
      tls:
        - secretName: backend-tls
          hosts:
            - api.example.com
            - backend.example.com
    # Example HPA configuration:
    # autoscaling:
    #   enabled: true
    #   minReplicas: 2
    #   maxReplicas: 10
    #   targetCPUUtilizationPercentage: 70
    #   targetMemoryUtilizationPercentage: 80
    #   behavior:
    #     scaleDown:
    #       stabilizationWindowSeconds: 60
    #       policies:
    #       - type: Percent
    #         value: 10
    #         periodSeconds: 60
    #     scaleUp:
    #       stabilizationWindowSeconds: 30
    #       policies:
    #       - type: Percent
    #         value: 50
    #         periodSeconds: 30
    env:
      - name: DATABASE_URL
        value: "postgresql://..."

  # Example ConfigMap configuration:
  # app-config:
  #   enabled: true
  #   image:
  #     repository: myapp/config
  #     tag: "v1.0.0"
  #   configMap:
  #     enabled: true
  #     annotations:
  #       config.kubernetes.io/source: "application-config"
  #     data:
  #       app.properties: |
  #         server.port=8080
  #         logging.level.root=INFO
  #         database.timeout=30
  #       nginx.conf: |
  #         server {
  #           listen 80;
  #           location / {
  #             proxy_pass http://backend:8080;
  #           }
  #         }
  #       config.json: |
  #         {
  #           "features": {
  #             "auth": true,
  #             "analytics": false
  #           },
  #           "api": {
  #             "timeout": 5000,
  #             "retries": 3
  #           }
  #         }

  # Example job configuration:
  # migration:
  #   enabled: true
  #   image:
  #     repository: myapp/migration
  #     tag: "v1.0.0"
  #   job:
  #     enabled: true
  #     restartPolicy: Never        # Never, OnFailure
  #     backoffLimit: 3             # Number of retries before marking job as failed
  #     activeDeadlineSeconds: 600  # Maximum duration for job execution
  #     ttlSecondsAfterFinished: 86400  # Clean up job after 24 hours
  #     command: ["python", "manage.py", "migrate"]
  #     annotations:
  #       helm.sh/hook: pre-install,pre-upgrade
  #       helm.sh/hook-weight: "1"
  #   env:
  #     - name: DATABASE_URL
  #       value: "postgresql://..."

  # Example CronJob configuration:
  # backup:
  #   enabled: true
  #   image:
  #     repository: myapp/backup
  #     tag: "v1.0.0"
  #   cronJob:
  #     enabled: true
  #     schedule: "0 2 * * *"          # Daily at 2 AM
  #     timeZone: "UTC"                # Optional timezone
  #     concurrencyPolicy: Forbid      # Forbid, Allow, Replace
  #     suspend: false                 # Suspend cron job execution
  #     successfulJobsHistoryLimit: 3  # Keep last 3 successful jobs
  #     failedJobsHistoryLimit: 1      # Keep last 1 failed job
  #     startingDeadlineSeconds: 200   # Deadline for starting the job if missed
  #     activeDeadlineSeconds: 3600    # Maximum duration for job execution (1 hour)
  #     backoffLimit: 3                # Number of retries before marking job as failed
  #     ttlSecondsAfterFinished: 86400 # Clean up job after 24 hours
  #     restartPolicy: OnFailure       # Never, OnFailure
  #     command: ["sh", "-c"]
  #     args: ["pg_dump $DATABASE_URL > /backup/db-$(date +%Y%m%d-%H%M%S).sql"]
  #     annotations:
  #       backup.kubernetes.io/schedule: "daily"
  #     jobAnnotations:
  #       backup.kubernetes.io/type: "database"
  #     podAnnotations:
  #       backup.kubernetes.io/retention: "30d"
  #   env:
  #     - name: DATABASE_URL
  #       valueFrom:
  #         secretKeyRef:
  #           name: database-secret
  #           key: url
  #     - name: BACKUP_RETENTION_DAYS
  #       value: "30"

  # Example ExternalSecret configuration:
  # app-secrets:
  #   enabled: true
  #   image:
  #     repository: myapp/api
  #     tag: "v1.0.0"
  #   externalSecret:
  #     enabled: true
  #     refreshInterval: "15m"
  #     secretStoreRef:
  #       name: aws-secrets-store
  #       kind: SecretStore
  #     target:
  #       name: app-secrets
  #       creationPolicy: Owner
  #       template:
  #         type: Opaque
  #         metadata:
  #           labels:
  #             app.kubernetes.io/name: app-secrets
  #         data:
  #           DATABASE_URL: "postgresql://{{ .username }}:{{ .password }}@{{ .host }}:{{ .port }}/{{ .database }}"
  #           REDIS_URL: "redis://{{ .redis_host }}:{{ .redis_port }}"
  #     data:
  #       - secretKey: username
  #         remoteRef:
  #           key: myapp/database
  #           property: username
  #       - secretKey: password
  #         remoteRef:
  #           key: myapp/database
  #           property: password
  #       - secretKey: host
  #         remoteRef:
  #           key: myapp/database
  #           property: host
  #       - secretKey: port
  #         remoteRef:
  #           key: myapp/database
  #           property: port
  #       - secretKey: database
  #         remoteRef:
  #           key: myapp/database
  #           property: database
  #       - secretKey: redis_host
  #         remoteRef:
  #           key: myapp/redis
  #           property: host
  #       - secretKey: redis_port
  #         remoteRef:
  #           key: myapp/redis
  #           property: port

# Global ingress configuration (optional)
# This can route traffic to multiple services from a single ingress
ingress:
  enabled: false
  className: ""
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  hosts:
    - host: myapp.example.com
      paths:
        - path: /
          pathType: Prefix
          serviceName: frontend    # Reference to deployment name
          servicePort: 80
        - path: /api
          pathType: Prefix
          serviceName: backend     # Reference to deployment name
          servicePort: 8080
  tls: []
    # - secretName: myapp-tls
    #   hosts:
    #     - myapp.example.com

# Image pull secrets (applied to all deployments by default)
imagePullSecrets: []

# Service Account (used as default for all deployments)
serviceAccount:
  create: true
  annotations: {}
  name: ""

# Global pod configuration (used as defaults for all deployments)
podAnnotations: {}
podLabels: {}

# Global security contexts (used as defaults for all deployments)
securityContext:
  runAsNonRoot: true
  runAsUser: 1000
  fsGroup: 2000

containerSecurityContext:
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: true
  runAsNonRoot: true
  runAsUser: 1000
  capabilities:
    drop:
    - ALL

# Global resource defaults (can be overridden per deployment)
resources:
  limits:
    cpu: 500m
    memory: 512Mi
  requests:
    cpu: 250m
    memory: 256Mi

# Global node selection (can be overridden per deployment)
nodeSelector: {}

# Global tolerations (can be overridden per deployment)
tolerations: []

# Global affinity rules (can be overridden per deployment)
affinity: {}

# Global topology spread constraints
topologySpreadConstraints: []

# Global host aliases
hostAliases: []

# Global DNS configuration
dnsPolicy: ""
dnsConfig: {}

# Global priority class
priorityClassName: ""

# Global restart policy
restartPolicy: ""

# Global grace period for pod termination
terminationGracePeriodSeconds: 30

# Global ConfigMaps (shared across all deployments)
configMaps:
  enabled: false
  maps: {}
    # Example global ConfigMaps:
    # shared-config:
    #   annotations:
    #     config.kubernetes.io/source: "shared-configuration"
    #   data:
    #     database.properties: |
    #       host=postgres.example.com
    #       port=5432
    #       database=myapp
    #       ssl=true
    #     redis.conf: |
    #       maxmemory 256mb
    #       maxmemory-policy allkeys-lru
    #       save 900 1
    # logging-config:
    #   data:
    #     log4j.properties: |
    #       log4j.rootLogger=INFO, stdout
    #       log4j.appender.stdout=org.apache.log4j.ConsoleAppender
    #       log4j.appender.stdout.layout=org.apache.log4j.PatternLayout

# Global ExternalSecrets (shared across all deployments)
externalSecrets:
  enabled: false
  secrets: {}
    # Example global ExternalSecrets:
    # database-credentials:
    #   refreshInterval: "1h"
    #   secretStoreRef:
    #     name: vault-backend
    #     kind: SecretStore
    #   target:
    #     name: database-credentials
    #     creationPolicy: Owner
    #     template:
    #       type: Opaque
    #       data:
    #         DATABASE_URL: "postgresql://{{ .username }}:{{ .password }}@{{ .host }}:5432/{{ .database }}"
    #   data:
    #     - secretKey: username
    #       remoteRef:
    #         key: secret/database
    #         property: username
    #     - secretKey: password
    #       remoteRef:
    #         key: secret/database
    #         property: password
    #     - secretKey: host
    #       remoteRef:
    #         key: secret/database
    #         property: host
    #     - secretKey: database
    #       remoteRef:
    #         key: secret/database
    #         property: database
    # api-keys:
    #   refreshInterval: "30m"
    #   secretStoreRef:
    #     name: aws-secrets-manager
    #     kind: ClusterSecretStore
    #   target:
    #     name: api-keys
    #     creationPolicy: Owner
    #   dataFrom:
    #     - extract:
    #         key: myapp/api-keys
    #       rewrite:
    #         - regexp:
    #             source: "(.*)_key$"
    #             target: "$1_API_KEY"
